<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Sourdough</title>
    <meta name="description" content="Sourdough journal" />
    <script src="https://cdn.jsdelivr.net/npm/heic2any@0.0.4/dist/heic2any.min.js"></script>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üçû</text></svg>">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&family=Permanent+Marker&display=swap"
      rel="stylesheet"
    />
    <style>
      /* Reset based on: https://www.joshwcomeau.com/css/custom-css-reset/ */
      * { box-sizing: border-box; }
      body { -webkit-font-smoothing: antialiased; }
      img, picture, video, canvas, svg {
        display: block;
        max-width: 100%;
      }
      input, button, textarea, select, ::-webkit-file-upload-button, ::file-selector-button {
        cursor: pointer;
        font: inherit;
      }
      p, h1, h2, h3, h4, h5, h6 { overflow-wrap: break-word; }
      p { text-wrap: pretty; }
      h1, h2, h3, h4, h5, h6 { text-wrap: balance; }

      body {
        font-family: "IBM Plex Mono", monospace;
        padding: 1em;
        line-height: 1.6em;
        background-color: beige;
      }

      h1,h2,h3 { font-family: "Permanent Marker", cursive; }
      h1 { font-size: 2.8em; }
      h2 { font-size: 1.5em; }
      a { color: peru; }
      li { padding-block: 0.25em; }
      input, textarea { width: 100%; }

      .marker-bread::marker { content: "üçû "; }
      .marker-clock::marker { content: "üïí "; }

      .grid {
        padding-block-start: 4em; /* nav buttons */
        display: grid;
        gap: 1em;
        grid-template: repeat(auto-fit, 200px) / repeat(auto-fit, minmax(200px, 1fr));
      }

      #bake-list { display: contents; }

      #nav-site {
        position: fixed;
        inset-inline-end: 1.5em;
        inset-block-start: 1.5em;
        display: flex;
        gap: 1em;
        z-index: 999;

        > a, button {
          display: block;
          text-decoration: none;
          background-color: ivory;
          border-radius: 50%;
          font-size: 1.5em;
          width: 2em;
          height: 2em;
          display: flex;
          align-items: center;
          justify-content: center;
          padding: 0;
          border: 0;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
          flex: 0 0 auto;
        }
      }

      #recipe {
        max-width: 60ch;
        margin: auto;
        text-wrap: pretty;
        padding-inline: 1.5em;

        /* phones */
        @media (max-width: 767px) {
          order: 999; /* last row */
          grid-column: 1 / -1; /* full width */
        }

        /* tablets+ */
        @media (min-width: 768px) {
          grid-column: span 2; /* 3+ columns at this size */
          grid-row: span 7; /* avoids tall row track with sparse photos */
        }
      }

      dialog {
        width: 90%;
        max-width: 350px;
      }

      .bake {
        cursor: pointer;
        position: relative;
        border-radius: 15px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        overflow: hidden;
        max-width: 400px;
        width: 100%;
        justify-self: end;
        height: 200px;

        & .bake-pic {
          position: absolute;
          inset: 0;
          width: 100%;
          height: 100%;
          object-fit: cover;
        }

        & .bake-overlay {
          position: absolute;
          inset: 0;
          display: flex;
          flex-direction: column;
          justify-content: end;
          padding: 1em;
          color: whitesmoke;
          text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.7);
          background: linear-gradient(
            to bottom,
            rgba(0, 0, 0, 0.0) 50%,
            rgba(0, 0, 0, 0.7)
          );
        }
      }

      .bake-photos img {
        max-width: 100px;
        max-height: 100px;
        width: auto;
        height: auto;
        object-fit: contain;
        margin: 5px;
      }

      #notification-popover {
        width: 80%;
        max-width: 300px;
        padding: 1em;
        border: 1px solid slategray;
        border-radius: 0.7em;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);

        position: fixed;
        inset: unset;
        inset-block-start: 1em;
        inset-inline-end: 1em;
        margin: 0;
      }
    </style>
  </head>
  <body>
    <nav id="nav-site">
    <a href="#recipe" title="recipe">üçû</a>
    <button id="bake-new" title="add">+</button>
    <button id="bake-export" title="export">üíæ</button>
    <button id="bake-import" title="import">üìÇ</button>
    <button id="bake-clear-all" title="clear all">üóëÔ∏è</button>
  </nav>

    <div class="grid">
      <section id="recipe">
        <h1 style="margin-block-start: 0.25em;">Recipe</h1>
        <p><a href="https://jch.github.io/posts/2025-04-29-sourdough.html">Jerry Cheung</a></p>
        <ul>
          <li class="marker-bread">200g levain</li>
          <li class="marker-bread">700g water</li>
          <li class="marker-bread">25g salt</li>
          <li class="marker-bread">800g bread | all-purpose</li>
          <li class="marker-bread">200g wheat flour</li>
        </ul>
        <ol>
          <li>Feed night before starter/flour/water 1:1:1 (most sour) to 1:5:5 (least sour)</li>
          <li>Ferment by volume using a small clear glass (e.g. shot glass)</li>
          <li>Stir: 200g levain, 700g water, 25g salt</li>
          <li>Stir: 800g bread flour, 200g wheat flour</li>
          <li>Hand knead 10 minutes</li>
          <li>Shape and rise until doubled. Optional stretch and fold, coil folds.</li>
          <li>Preheat oven for 60 minutes at 500F with pizza stone</li>
        </ol>
        <h2>Notes</h2>
        <p>
          1:1 ratio water/flour for levain makes it easier to stir. Control
          sourness with how much existing starter to use.
        </p>
        <p>
          Easy math: (100g levain water + 700g water) / (100g levain flour +
          1000g flour) = 72.7% hydration. 25g salt / 1100 = 2.3% salt.
        </p>
        <p>
          Stirring levain, water, and salt together first makes it homogeneous
          before adding flour.
        </p>
        <p>
          I hand kneading over autolyse for initial gluten development because
          it guarantees a well mixed dough. It lets me do all the steps before
          bulk rise at once and fits well with a work schedule.
        </p>
        <p>
          To measure bulk rise, I tear off a small piece of dough, put it into
          the bottom of a shot glass, and wrap a rubber band on the outside to
          mark the initial height. I bulk rise at room temperature between
          5-8hrs.
        </p>
        <p>
          I use Bulka round bannetons and a Lodge cast iron loaf pan if I cold
          proof overnight.
        </p>
        <p>Thanks Sarah for sharing your starter with me!</p>
        <h2>Schedules</h2>
        <ul>
          <li class="marker-clock">Default: levain overnight, mix everything in the morning, bulk rise during work, bake after work.</li>
          <li class="marker-clock">Fast morning: levain overnight, autolyse overnight, mix levain with dough, bulk rise during work, bake after work.</li>
          <li class="marker-clock">Busy afternoon: cold proof overnight, bake in the morning.</li>
          <li class="marker-clock">Split rise: if dough isn't risen by bedtime, cold-proof overnight, take it out in the morning for additional rise.</li>
        </ul>
      </section>
      <div id="bake-list"></div>
    </div>

    <dialog id="bake-editor">
      <form method="dialog" style="display: flex; justify-content: end;">
        <button type="submit">close</button>
      </form>

      <form id="bake-form">
        <p><input type="text" name="name" placeholder="name" autofocus /></p>
        <p><input type="date" name="date" /></p>
        <p><textarea name="notes" rows="5" placeholder="notes"></textarea></p>
        <p>
          <input type="file" name="photos" accept="image/*" multiple capture />
        </p>
        <p style="display: flex; justify-content: space-between">
          <button type="submit">Save</button>
          <button
            type="button"
            id="delete-bake-button"
            style="display: none; color: crimson"
          >
            Delete
          </button>
        </p>
      </form>
    </dialog>

    <template id="bake-template">
      <article class="bake">
        <img class="bake-pic" src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext x='50%' y='50%' dominant-baseline='middle' text-anchor='middle' font-size='45'%3Eüçû%3C/text%3E%3C/svg%3E" />
        <div class="bake-overlay">
          <h2 class="bake-name" style="margin-bottom: 0"></h2>
          <time class="bake-date" datetime=""></time>
        </div>
      </article>
    </template>

    <template id="bake-form-template">
      <form id="bake-form">
        <p><input type="text" name="name" placeholder="name" /></p>
        <p><input type="date" name="date" /></p>
        <p><textarea name="notes" rows="5" placeholder="notes"></textarea></p>
        <p>
          <input type="file" name="photos" accept="image/*" multiple capture />
        </p>
        <p style="display: flex; justify-content: space-between">
          <button type="submit">Save</button>
          <button type="button" id="delete-bake-button" style="display: none; color: crimson">
            Delete
          </button>
        </p>
      </form>
    </template>


    <dialog id="import-dialog">
      <form method="dialog" style="display: flex; justify-content: end;">
        <button type="submit">close</button>
      </form>

      <h3>Import Bakes</h3>
      <p>Choose a JSON file with bakes to import. This will replace all existing bakes.</p>
      <form id="import-form">
        <p><input type="file" id="import-file" accept=".json" required /></p>
        <button type="submit" id="import-submit">Import</button>
      </form>
    </dialog>
    <script>
      // Model - handles data operations
      class BakeModel {
        constructor() {
          this.dbName = "SourdoughDB";
          this.dbVersion = 1;
          this.db = null;
        }

        async init() {
          return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, this.dbVersion);

            request.onerror = (event) => {
              console.error("IndexedDB error:", event.target.error);
              reject("Error opening database");
            };

            request.onsuccess = (event) => {
              this.db = event.target.result;
              console.log("Database opened successfully");
              resolve(this.db);
            };

            request.onupgradeneeded = (event) => {
              const db = event.target.result;
              if (!db.objectStoreNames.contains("bakes")) {
                const bakeStore = db.createObjectStore("bakes", {
                  keyPath: "id",
                  autoIncrement: true,
                });
                bakeStore.createIndex("date", "date", { unique: false });
                bakeStore.createIndex("name", "name", { unique: false });
              }
            };
          });
        }

        async getAll() {
          return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(["bakes"], "readonly");
            const store = transaction.objectStore("bakes");
            const request = store.getAll();

            request.onsuccess = (event) => resolve(event.target.result);
            request.onerror = (event) => reject(event.target.error);
          });
        }

        async getById(id) {
          return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(["bakes"], "readonly");
            const store = transaction.objectStore("bakes");
            const request = store.get(id);

            request.onsuccess = (event) => resolve(event.target.result);
            request.onerror = (event) => reject(event.target.error);
          });
        }

        async create(bake) {
          return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(["bakes"], "readwrite");
            const store = transaction.objectStore("bakes");
            const request = store.add(bake);

            request.onsuccess = (event) => resolve(event.target.result);
            request.onerror = (event) => reject(event.target.error);
          });
        }

        async update(bake) {
          return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(["bakes"], "readwrite");
            const store = transaction.objectStore("bakes");
            const request = store.put(bake);

            request.onsuccess = (event) => resolve(event.target.result);
            request.onerror = (event) => reject(event.target.error);
          });
        }

        async delete(id) {
          return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(["bakes"], "readwrite");
            const store = transaction.objectStore("bakes");
            const request = store.delete(id);

            request.onsuccess = () => resolve();
            request.onerror = (event) => reject(event.target.error);
          });
        }

        async clearAll() {
          return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(["bakes"], "readwrite");
            const store = transaction.objectStore("bakes");
            const request = store.clear();

            request.onsuccess = () => resolve();
            request.onerror = (event) => reject(event.target.error);
          });
        }
      }

      // View - handles UI rendering
      class BakeView {
        constructor() {
          this.bakeTemplate = document.getElementById("bake-template");
          this.bakeListContainer = document.getElementById("bake-list");
          this.dialogElement = document.getElementById("bake-editor");
          this.formTemplate = document.getElementById("bake-form-template");
        }

        renderBakeList(bakes) {
          this.bakeListContainer.innerHTML = "";

          // Sort bakes by date (newest first), tiebreak on id
          bakes.sort((a, b) => {
            const dateComparison = new Date(b.date) - new Date(a.date);
            return dateComparison !== 0 ? dateComparison : b.id - a.id;
          });

          for (const bake of bakes) {
            const bakeElement = this.bakeTemplate.content.cloneNode(true).querySelector("article");
            bakeElement.id = `bake-${bake.id}`;

            const nameElement = bakeElement.querySelector(".bake-name");
            nameElement.textContent = bake.name || `#${bake.id}`;

            const [year, month, day] = bake.date.split("-").map(num => parseInt(num, 10));
            const dateObj = new Date(year, month - 1, day);
            const formattedDate = dateObj.toLocaleDateString("en-US", {
              year: "numeric",
              month: "short",
              day: "numeric",
            });

            const timeElement = bakeElement.querySelector("time");
            timeElement.setAttribute("datetime", bake.date);
            timeElement.textContent = formattedDate;

            // Set image if available
            const imgElement = bakeElement.querySelector(".bake-pic");
            if (bake.photos && bake.photos.length > 0) {
              const firstPhoto = bake.photos[0];
              if (firstPhoto) {
                // Handle different possible formats of stored photos
                if (firstPhoto instanceof Blob) {
                  // It's already a Blob object (from file input)
                  if (firstPhoto.type && firstPhoto.type.includes("heic")) {
                    heic2any({ blob: firstPhoto, toType: "image/jpeg", quality: 0.5 })
                      .then((converted) => {
                        const objectUrl = URL.createObjectURL(converted);
                        imgElement.src = objectUrl;
                        imgElement.onload = () => URL.revokeObjectURL(objectUrl);
                      })
                      .catch(error => console.error("Error converting HEIC:", error));
                  } else {
                    const objectUrl = URL.createObjectURL(firstPhoto);
                    imgElement.src = objectUrl;
                    imgElement.onload = () => URL.revokeObjectURL(objectUrl);
                  }
                } else if (typeof firstPhoto === 'string') {
                  // It's likely a data URL string
                  imgElement.src = firstPhoto;
                } else if (firstPhoto.data) {
                  // It's an object with a data property (stored data URL)
                  imgElement.src = firstPhoto.data;
                }
              }
            }

            this.bakeListContainer.appendChild(bakeElement);
          }
        }

        showEditor(bake = null) {
          // Get the dialog element
          const dialog = this.dialogElement;

          // Clear the dialog content except for the close button form
          const closeButtonForm = dialog.querySelector('form[method="dialog"]');
          dialog.innerHTML = '';
          dialog.appendChild(closeButtonForm);

          // Clone the form template
          const formClone = this.formTemplate.content.cloneNode(true);
          const form = formClone.querySelector("form");

          // Add the form to the dialog
          dialog.appendChild(form);

          // Get today's date as default
          const today = new Date();
          const formattedDate = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, "0")}-${String(today.getDate()).padStart(2, "0")}`;
          form.date.value = formattedDate;

          // Create photo container
          const photoContainer = document.createElement("div");
          photoContainer.id = "photo-container";
          photoContainer.className = "bake-photos";
          photoContainer.style.marginTop = "10px";

          const submitButtonParent = form.querySelector('button[type="submit"]').parentNode;
          form.insertBefore(photoContainer, submitButtonParent);

          // Set up photo input change listener
          const photoInput = form.querySelector('input[type="file"]');
          photoInput.addEventListener("change", async (event) => {
            await this.displaySelectedPhotos(Array.from(event.target.files));
          });

          const deleteButton = form.querySelector("#delete-bake-button");
          const submitButton = form.querySelector('button[type="submit"]');

          if (bake) {
            // Editing existing bake
            form.name.value = bake.name || "";
            form.date.value = bake.date || "";
            form.notes.value = bake.notes || "";
            form.dataset.bakeId = bake.id;

            // Show delete button
            deleteButton.style.display = "inline-block";

            // Display existing photos
            this.displayExistingPhotos(bake, photoContainer);

            submitButton.textContent = "Update";
          } else {
            // Creating new bake
            form.dataset.bakeId = "";
            deleteButton.style.display = "none";
            submitButton.textContent = "Save";
          }

          dialog.showModal();
          form.name.focus();

          return form;
        }

        displayExistingPhotos(bake, photoContainer) {
          if (!bake.photos || bake.photos.length === 0) {
            return;
          }

          // Create a section for existing photos
          const existingPhotosSection = document.createElement("div");
          existingPhotosSection.className = "existing-photos-section";

          const heading = document.createElement("h4");
          heading.textContent = "Existing Photos";
          heading.style.margin = "10px 0 5px 0";

          existingPhotosSection.appendChild(heading);
          photoContainer.appendChild(existingPhotosSection);

          // Create a flexbox container for photos
          const photoGrid = document.createElement("div");
          photoGrid.className = "photo-grid";
          photoGrid.style.display = "flex";
          photoGrid.style.flexWrap = "wrap";
          photoGrid.style.gap = "8px";
          existingPhotosSection.appendChild(photoGrid);

          // Add each photo to the grid
          bake.photos.forEach((photo, index) => {
            const photoContainer = document.createElement("div");
            photoContainer.className = "photo-item";
            photoContainer.style.position = "relative";

            const img = document.createElement("img");
            img.src = typeof photo === 'string' ? photo : (photo.data || '');
            img.alt = (photo.name || `Photo ${index + 1}`);
            img.title = (photo.name || `Photo ${index + 1}`);

            const checkboxLabel = document.createElement("label");
            checkboxLabel.className = "photo-checkbox-label";
            checkboxLabel.style.position = "absolute";
            checkboxLabel.style.top = "5px";
            checkboxLabel.style.left = "5px";
            checkboxLabel.style.zIndex = "10";
            checkboxLabel.style.background = "rgba(255, 255, 255, 0.7)";
            checkboxLabel.style.borderRadius = "3px";
            checkboxLabel.style.padding = "2px";

            const checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.checked = true;
            checkbox.className = "keep-photo-checkbox";
            checkbox.setAttribute("data-photo-index", index);
            checkbox.id = `keep-photo-${index}`;
            checkbox.style.margin = "0";

            checkboxLabel.appendChild(checkbox);
            photoContainer.appendChild(img);
            photoContainer.appendChild(checkboxLabel);
            photoGrid.appendChild(photoContainer);
          });
        }

        async displaySelectedPhotos(files) {
          if (files.length === 0) return;

          const photoContainer = document.getElementById("photo-container");
          if (!photoContainer) return;

          let newPhotosSection = photoContainer.querySelector(".new-photos-section");
          if (!newPhotosSection) {
            newPhotosSection = document.createElement("div");
            newPhotosSection.className = "new-photos-section";

            const heading = document.createElement("h4");
            heading.textContent = "New Photos";
            heading.style.margin = "10px 0 5px 0";

            newPhotosSection.appendChild(heading);
            photoContainer.appendChild(newPhotosSection);
          } else {
            const heading = newPhotosSection.querySelector("h4");
            newPhotosSection.innerHTML = "";
            newPhotosSection.appendChild(heading);
          }

          const photoGrid = document.createElement("div");
          photoGrid.className = "photo-grid";
          photoGrid.style.display = "flex";
          photoGrid.style.flexWrap = "wrap";
          photoGrid.style.gap = "8px";
          newPhotosSection.appendChild(photoGrid);

          const loadingMsg = document.createElement("p");
          loadingMsg.textContent = `Loading ${files.length} image(s)...`;
          loadingMsg.style.margin = "5px 0";
          newPhotosSection.insertBefore(loadingMsg, photoGrid);

          for (const file of files) {
            try {
              if (!file.type.startsWith("image/")) continue;

              let imageUrl;

              if (file.type === "image/heic" || file.name.toLowerCase().endsWith(".heic")) {
                const jpegBlob = await heic2any({
                  blob: file,
                  toType: "image/jpeg",
                  quality: 0.8,
                });
                imageUrl = URL.createObjectURL(jpegBlob);
              } else {
                imageUrl = URL.createObjectURL(file);
              }

              const img = document.createElement("img");
              img.src = imageUrl;
              img.alt = file.name;
              img.title = file.name;

              photoGrid.appendChild(img);
            } catch (err) {
              console.error("Error previewing image:", err);
            }
          }

          if (loadingMsg && loadingMsg.parentNode) {
            loadingMsg.remove();
          }
        }
      }

      // Controller - handles user interactions and coordinates model/view
      class BakeController {
        constructor() {
          this.model = new BakeModel();
          this.view = new BakeView();
        }

        async init() {
          try {
            await this.model.init();

            // Initial display of bakes
            await this.index();

            // Set up event listeners for buttons in the navigation
            this.setupNavButtons();
          } catch (error) {
            console.error("Initialization error:", error);
          }
        }

        setupNavButtons() {
          // Add bake button
          document.querySelector('button#bake-new')
            .onclick = (e) => {
              e.preventDefault();
              this.new();
            };

          // Delete all button
          document.querySelector('button#bake-clear-all')
            .onclick = (e) => {
              e.preventDefault();
              this.clearAll();
            };

          // Export button
          document.querySelector('button#bake-export')
            .onclick = (e) => {
              e.preventDefault();
              this.export();
            };

          // Import button
          document.querySelector('button#bake-import')
            .onclick = (e) => {
              e.preventDefault();
              this.import();
            };
        }

        async index() {
          try {
            let bakes = await this.model.getAll();

            // If no bakes exist in the database, fetch bakes.json and load it
            if (bakes.length === 0) {
              console.log("No bakes found in IndexedDB. Fetching bakes.json...");
              try {
                const response = await fetch("bakes.json");
                if (!response.ok) {
                  throw new Error(`Failed to fetch bakes.json: ${response.statusText}`);
                }

                const importedBakes = await response.json();
                if (Array.isArray(importedBakes)) {
                  for (const bake of importedBakes) {
                    // Ensure required fields exist
                    if (!bake.date) {
                      bake.date = new Date().toISOString().split('T')[0];
                    }

                    // Add creation timestamp if missing
                    if (!bake.createdAt) {
                      bake.createdAt = new Date().toISOString();
                    }

                    await this.model.create(bake);
                  }

                  console.log(`Loaded ${importedBakes.length} bakes from bakes.json into IndexedDB.`);
                  bakes = await this.model.getAll(); // Refresh the list after loading
                } else {
                  console.error("Invalid data format in bakes.json. Expected an array of bakes.");
                }
              } catch (fetchError) {
                console.error("Error fetching or loading bakes.json:", fetchError);
              }
            }

            this.view.renderBakeList(bakes);

            // Add click event to each bake element
            document.querySelectorAll('.bake').forEach(bake => {
              bake.addEventListener('click', (e) => {
                const bakeId = parseInt(e.currentTarget.id.replace('bake-', ''));
                this.show(bakeId);
              });
            });
          } catch (error) {
            console.error("Error displaying bakes:", error);
          }
        }

        new() {
          const form = this.view.showEditor();
          form.addEventListener("submit", (e) => this.handleFormSubmit(e));

          // Handle delete button since we're using cloned form
          const deleteButton = form.querySelector("#delete-bake-button");
          if (deleteButton) {
            deleteButton.style.display = "none";
          }
        }

        async show(bakeId) {
          try {
            const bake = await this.model.getById(bakeId);
            if (bake) {
              const form = this.view.showEditor(bake);
              form.addEventListener("submit", (e) => this.handleFormSubmit(e));

              // Set up delete button
              const deleteButton = form.querySelector("#delete-bake-button");
              if (deleteButton) {
                deleteButton.addEventListener("click", () => this.delete(bakeId));
              }
            } else {
              console.error(`Could not find bake #${bakeId}`);
            }
          } catch (error) {
            console.error(`Error opening bake #${bakeId}:`, error);
          }
        }

        async handleFormSubmit(event) {
          event.preventDefault();

          const form = event.target;
          const submitButton = form.querySelector('button[type="submit"]');
          const originalButtonText = submitButton.textContent;
          submitButton.textContent = "Saving...";
          submitButton.disabled = true;

          const name = form.name.value.trim();
          const date = form.date.value;
          const notes = form.notes.value.trim();
          const photos = await Promise.all(
            Array.from(form.photos.files).map(async (file) => {
              if (file.type === "image/heic" || file.name.toLowerCase().endsWith(".heic")) {
                try {
                  const jpegBlob = await heic2any({
                    blob: file,
                    toType: "image/jpeg",
                    quality: 0.8,
                  });
                  return new File([jpegBlob], file.name.replace(/\.heic$/i, ".jpeg"), {
                    type: "image/jpeg",
                  });
                } catch (err) {
                  console.error("Error converting HEIC to JPEG:", err);
                  return null;
                }
              }
              return file;
            })
          ).then((files) => files.filter((file) => file !== null));
          const bakeId = parseInt(form.dataset.bakeId) || null;

          try {
            let id;
            if (bakeId) {
              // Update existing bake
              const existingBake = await this.model.getById(bakeId);

              existingBake.name = name;
              existingBake.date = date;
              existingBake.notes = notes;
              existingBake.updatedAt = new Date().toISOString();

              // Handle photo deletions
              const keepPhotoCheckboxes = form.querySelectorAll(".keep-photo-checkbox");
              if (keepPhotoCheckboxes.length > 0 && existingBake.photos) {
                const photosToKeep = [];

                existingBake.photos.forEach((photo, index) => {
                  const checkbox = Array.from(keepPhotoCheckboxes).find(
                    cb => parseInt(cb.getAttribute("data-photo-index")) === index
                  );

                  if (checkbox && checkbox.checked) {
                    photosToKeep.push(photo);
                  }
                });

                existingBake.photos = photosToKeep;
              }

              // Add new photos
              if (photos.length > 0) {
                if (!existingBake.photos) {
                  existingBake.photos = [];
                }

                // Process each photo and convert to data URLs
                for (const file of photos) {
                  try {
                    if (!file.type.startsWith("image/")) continue;

                    const reader = new FileReader();
                    await new Promise((resolve, reject) => {
                      reader.onload = () => {
                        existingBake.photos.push({
                          name: file.name,
                          type: file.type,
                          data: reader.result,
                          addedAt: new Date().toISOString()
                        });
                        resolve();
                      };
                      reader.onerror = reject;
                      reader.readAsDataURL(file);
                    });
                  } catch (err) {
                    console.error("Error processing image:", err);
                  }
                }
              }

              await this.model.update(existingBake);
              id = bakeId;

              console.log(`Bake #${id} updated successfully!`);
            } else {
              // Create new bake
              const bake = {
                name,
                date,
                notes,
                photos: [],
                createdAt: new Date().toISOString(),
              };

              // Process photos for new bake
              for (const file of photos) {
                try {
                  if (!file.type.startsWith("image/")) continue;

                  const reader = new FileReader();
                  await new Promise((resolve, reject) => {
                    reader.onload = () => {
                      bake.photos.push({
                        name: file.name,
                        type: file.type,
                        data: reader.result,
                        addedAt: new Date().toISOString()
                      });
                      resolve();
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                  });
                } catch (err) {
                  console.error("Error processing image:", err);
                }
              }

              id = await this.model.create(bake);

              console.log(`Bake #${id} saved successfully!`);
            }

            // Close dialog and refresh list
            document.querySelector("#bake-editor").close();
            await this.index();
          } catch (error) {
            console.error("Error saving/updating bake:", error);
          } finally {
            submitButton.textContent = originalButtonText;
            submitButton.disabled = false;
          }
        }

        async delete(bakeId) {
          if (!confirm(`Are you sure you want to delete bake #${bakeId}? This cannot be undone.`)) {
            return;
          }

          try {
            await this.model.delete(bakeId);
            console.log(`Bake #${bakeId} deleted successfully!`);
            document.querySelector("#bake-editor").close();
            await this.index();
          } catch (error) {
            console.error(`Error deleting bake #${bakeId}:`, error);
          }
        }

        async clearAll() {
          if (!confirm("Are you sure you want to delete all bakes and images? This cannot be undone.")) {
            return;
          }

          try {
            await this.model.clearAll();
            console.log("All bakes have been cleared successfully");
            await this.index();
          } catch (error) {
            console.error("Error clearing bakes:", error);
          }
        }

        async export() {
          try {
            const bakes = await this.model.getAll();

            if (bakes.length === 0) {
              console.log("No bakes to export");
              return;
            }

            const dataStr = JSON.stringify(bakes, null, 2);
            const dataBlob = new Blob([dataStr], { type: "application/json" });

            const downloadLink = document.createElement("a");
            downloadLink.href = URL.createObjectURL(dataBlob);

            const date = new Date().toISOString().split("T")[0];
            downloadLink.download = `sourdough-bakes-${date}.json`;

            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);

            setTimeout(() => URL.revokeObjectURL(downloadLink.href), 100);

            console.log(`Exported ${bakes.length} bakes successfully!`);
          } catch (error) {
            console.error("Error exporting bakes:", error);
          }
        }
        async export() {
          try {
            const bakes = await this.model.getAll();

            if (bakes.length === 0) {
              console.log("No bakes to export");
              return;
            }

            const dataStr = JSON.stringify(bakes, null, 2);
            const dataBlob = new Blob([dataStr], { type: "application/json" });

            const downloadLink = document.createElement("a");
            downloadLink.href = URL.createObjectURL(dataBlob);

            const date = new Date().toISOString().split("T")[0];
            downloadLink.download = `sourdough-bakes-${date}.json`;

            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);

            setTimeout(() => URL.revokeObjectURL(downloadLink.href), 100);

            console.log(`Exported ${bakes.length} bakes successfully!`);
          } catch (error) {
            console.error("Error exporting bakes:", error);
          }
        }

        async import() {
          const importDialog = document.getElementById("import-dialog");
          const importForm = document.getElementById("import-form");
          const importFile = document.getElementById("import-file");

          // Reset the form
          importForm.reset();

          // Show the dialog
          importDialog.showModal();

          // Handle form submission
          importForm.onsubmit = async (e) => {
            e.preventDefault();

            if (!importFile.files || importFile.files.length === 0) {
              alert("Please select a file to import.");
              return;
            }

            const file = importFile.files[0];

            if (file.type !== "application/json" && !file.name.endsWith('.json')) {
              alert("Please select a JSON file.");
              return;
            }

            try {
              // Read the file content
              const reader = new FileReader();
              reader.onload = async (event) => {
                try {
                  const importedData = JSON.parse(event.target.result);

                  if (!Array.isArray(importedData)) {
                    throw new Error("Invalid data format. Expected an array of bakes.");
                  }

                  // Confirm replacement of existing data
                  const existingBakes = await this.model.getAll();
                  if (existingBakes.length > 0) {
                    if (!confirm(`This will replace your existing ${existingBakes.length} bake(s) with ${importedData.length} imported bake(s). Continue?`)) {
                      return;
                    }

                    // Clear existing data
                    await this.model.clearAll();
                  }

                  // Import each bake
                  let importCount = 0;
                  for (const bake of importedData) {
                    // Remove id to ensure we create new entries
                    const { id, ...bakeData } = bake;

                    // Ensure required fields exist
                    if (!bakeData.date) {
                      bakeData.date = new Date().toISOString().split('T')[0];
                    }

                    // Add creation timestamp if missing
                    if (!bakeData.createdAt) {
                      bakeData.createdAt = new Date().toISOString();
                    }

                    await this.model.create(bakeData);
                    importCount++;
                  }

                  console.log(`Imported ${importCount} bakes successfully!`);
                  importDialog.close();

                  // Refresh the list
                  await this.index();
                } catch (error) {
                  console.error("Import error:", error);
                  alert(`Error importing data: ${error.message}`);
                }
              };

              reader.readAsText(file);
            } catch (error) {
              console.error("Error reading file:", error);
              alert(`Error reading file: ${error.message}`);
            }
          };
        }


      }

      // Initialize the application when the DOM is ready
      document.addEventListener("DOMContentLoaded", () => {
        const bakeController = new BakeController();
        bakeController.init();
      });
    </script>
  </body>
</html>
