<!DOCTYPE html>
<html>
<head>
<meta content='width=device-width, initial-scale=1.0' name='viewport'>
<title>
Introspecting Rails Models and Controllers Callbacks
</title>
<link href="../../../../assets/application-d2f36cb0fed8eb4314e72d8f93f02530.css" media="all" rel="stylesheet" type="text/css" />
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-2747647-1']);
  _gaq.push(['_setSiteSpeedSampleRate', 100]);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>
<body class='container-fluid'>
<div class='full-width' id='wcc'>
<div id='header'>
<a href="../../../../index.html">whatcodecraves.com</a>
</div>

<div id='main'>
<div id="carbonads-container">
  <div class="carbonad">
    <div id="azcarbon"></div>
      <script type="text/javascript">
        var z = document.createElement("script");
        z.type = "text/javascript";
        z.async = true;
        z.src = "http://engine.carbonads.com/z/17311/azcarbon_2_1_0_VERT";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(z, s);
      </script>
    </div>
  </div>
<div class='post'>
<h1>Introspecting Rails Models and Controllers Callbacks</h1>
<a href="http://news.ycombinator.com/submit" class="hn-share-button">Vote on HN</a>
<a href="https://twitter.com/share" class="twitter-share-button" data_via="whatcodecraves">Tweet</a>
<div class='g-plus' data-action='share' data-annontation='bubble'></div>
<p>Once models and controllers grow to a certain size and complexity, it
gets tricky to figure out what callbacks act upon them.  This is
especially true for objects that are several inheritance layers deep,
have multiple mixins, were written a long long time ago, or any
combination of the above.  I've picked up a few tools for crushing
nasty little callback buggers that crop up every now and then.  I hope
you find them useful!</p><h2>ActiveRecord Callbacks</h2><p>Model validation and save callbacks are provided by the module
<a href="http://api.rubyonrails.org/classes/ActiveRecord/Callbacks.html">ActiveRecord::Callbacks</a>.
If you read through this code, you'll find that it's built on top of a
great little module called
<a href="http://api.rubyonrails.org/classes/ActiveSupport/Callbacks.html">ActiveSupport::Callbacks</a>.
I'm a big fan of this module because it gives you a nice abstraction
to defining callbacks on arbitrary Ruby objects.</p><p>The callbacks defined on ActiveRecord::Base sub-classes are</p><pre><code>after_find
after_initialize
before_save
after_save
before_create
after_create
before_update
after_update
before_validation
after_validation
before_validation_on_create
after_validation_on_create
before_validation_on_update
after_validation_on_update
before_destroy
after_destroy
</code></pre><p>To see the list of a particular callbacks, suffix the callback type
with '_callback_chain'.  For example, to see the 'before_save'
callbacks defined on the model Supplier:</p><pre><code>Supplier.before_save_callback_chain
</code></pre><p>This will give you a list of
<a href="http://api.rubyonrails.org/classes/ActiveSupport/Callbacks/Callback.html">ActiveSupport::Callbacks::Callback</a>
objects that have interesting attributes such as identifier, kind,
method, and options.</p><p>To get a named list of callbacks, do</p><pre><code>Supplier.before_save_callback_chain.map(&amp;:method)
</code></pre><p>To see whether a callback is conditional, check out it's 'options'</p><pre><code>Supplier.before_save_callback_chain.first.options
</code></pre><h2>ActionController Callback</h2><p>Controller callbacks documentation can be found at
<a href="http://api.rubyonrails.org/classes/ActionController/Filters/ClassMethods.html">ActionController::Filters::ClassMethods</a>.</p><p>SuppliersController.filter_chain</p><p>Again, the array of filter objects returned by 'filter_chain' are
ActiveSupport::Callbacks::Callback instances.  This lets you check the
method names being called, as well as what options are set on it.</p><h2>In General</h2><p>Unrelated to callbacks, but a useful debugging tool to figure out what
caused your code to be in it's current context, use
<a href="http://www.ruby-doc.org/core/classes/Kernel.html#M005955">Kernel.caller</a>
to get a list of filenames and methods of the call stack.  It's
usually pretty noisy, so I use
<a href="http://www.ruby-doc.org/core/classes/Enumerable.html#M003152">Enumerable#grep</a>
to filter for what I'm interested in.</p><pre><code>Kernel.caller.grep /supplier/
</code></pre><p>The combination of these 3 tips have helped me debug strange callback
order bugs, as well as help me learn about a complex model that I've
never dealt with before.  Unfortunately, I put off writing about this
topic for so long that I've forgotten some of the tips.  As always, I
found reading into the ActiveRecord and ActiveSupport code to be
particularly enlightening.  If you have some other interesting
introspection tips that help you develop, please share them in the
comments ;)</p>
</div>
<script src="../../../../assets/post-6546d1eaa44666cb1ab3152c118eceec.js" type="text/javascript"></script>
<script>
  //<![CDATA[
    hljs.initHighlightingOnLoad();
  //]]>
</script>
<script type='text/javascript'>
  // HackerNews
  (function(d, t) {
    var g = d.createElement(t),
        s = d.getElementsByTagName(t)[0];
    g.src = '//hnbutton.appspot.com/static/hn.js';
    s.parentNode.insertBefore(g, s);
  }(document, 'script'));

  // Twitter
  !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");

  // Google Plus
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>
<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname  = 'whatcodecraves';
  var disqus_title      = 'Introspecting Rails Models and Controllers Callbacks';
  var disqus_identifier = '/posts/2009/06/04/introspecting-rails-models-and-controllers';


  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


</div>
<div id='footer'>
<p>
Copyright Jerry Cheung 2007 - 2014 &nbsp;&nbsp;
<a href="https://github.com/jch/whatcoderaves.com">Source for this blog</a>
</p>
</div>
</div>
</body>
</html>
