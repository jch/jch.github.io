<!DOCTYPE html>
<html>
<head>
<meta content='width=device-width, initial-scale=1.0' name='viewport'>
<title>
Faraday: One HTTP Client to Rule Them All
</title>
<link href="../../../../assets/application-d2f36cb0fed8eb4314e72d8f93f02530.css" media="all" rel="stylesheet" type="text/css" />
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-2747647-1']);
  _gaq.push(['_setSiteSpeedSampleRate', 100]);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>
<body class='container-fluid'>
<div class='full-width' id='wcc'>
<div id='header'>
<a href="../../../../index.html">whatcodecraves.com</a>
</div>

<div id='main'>
<div id="carbonads-container">
  <div class="carbonad">
    <div id="azcarbon"></div>
      <script type="text/javascript">
        var z = document.createElement("script");
        z.type = "text/javascript";
        z.async = true;
        z.src = "http://engine.carbonads.com/z/17311/azcarbon_2_1_0_VERT";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(z, s);
      </script>
    </div>
  </div>
<div class='post'>
<h1>Faraday: One HTTP Client to Rule Them All</h1>
<a href="http://news.ycombinator.com/submit" class="hn-share-button">Vote on HN</a>
<a href="https://twitter.com/share" class="twitter-share-button" data_via="whatcodecraves">Tweet</a>
<div class='g-plus' data-action='share' data-annontation='bubble'></div>
<p><img align="right" src="../../../../images/faraday-cage.jpg">
Faraday is a Ruby HTTP client which allow developers to customize its behavior with middlewares. If you're familiar with <a href="http://rack.rubyforge.org/">Rack</a>, then you'll love Faraday. Rather than re-implement yet another HTTP client, Faraday has adapters for popular libraries like Net::HTTP, excon, patron, and em-http. On top of having a consistent interface between different adapters, Faraday also allows you to manipulate request and responses before and after a request is executed.  This tutorial gives an introduction of common use cases built into Faraday, and also explains how to extend Faraday with custom middleware. The code is well tested and easy to follow, so I recommend browsing the source code to find extra options and features not covered in this tutorial.</p><h2>Basics</h2><p>Out of the box, Faraday functions like a normal HTTP client with a easy to use interface.</p><pre><code class="ruby">Faraday.get 'http://example.com'
</code></pre><p>Alternatively, you can initialize a <code>Faraday::Connection</code> instance:</p><pre><code class="ruby">conn = Faraday.new
response = conn.get 'http://example.com'
response.status
response.body

conn.post 'http://example.com', :some_param =&gt; 'Some Value'
conn.put  'http://example.com', :other_param =&gt; 'Other Value'
conn.delete 'http://example.com/foo'
# head, patch, and options all work similarly
</code></pre><p>Parameters can be set inline as the 2nd hash argument. To specify headers, add optional hash after the parameters argument or set them through an accessor:</p><pre><code class="ruby">conn.get 'http://example.com', {}, {'Accept' =&gt; 'vnd.github-v3+json'}

conn.params  = {'tesla' =&gt; 'coil'}
conn.headers = {'Accept' =&gt; 'vnd.github-v3+json'}
</code></pre><p>If you have a restful resource you're accessing with a common base url, you can pass in a <code>:url</code> parameter that'll be prefixed to all other calls. Other request options can also be set here.</p><pre><code class="ruby">conn = Faraday.new(:url =&gt; 'http://example.com/comments')
conn.get '/index'  # GET http://example.com/comments/index
</code></pre><p>All HTTP verb methods can take an optional block that will yield a <code>Faraday::Request</code> object:</p><pre><code class="ruby">conn.get '/' do |request|
  request.params['limit'] = 100
  request.headers['Content-Type'] = 'application/json'
  request.body = "{some: body}"
end
</code></pre><h3>File upload</h3><pre><code class="ruby">payload = { :name =&gt; 'Maguro' }

# uploading a file:
payload = { :profile_pic =&gt; Faraday::UploadIO.new('avatar.jpg', 'image/jpeg') }

# "Multipart" middleware detects files and encodes with "multipart/form-data":
conn.put '/profile', payload
</code></pre><h3>Authentication</h3><p>Basic and Token authentication are handled by <code>Faraday::Request::BasicAuthentication</code> and <code>Faraday::Request::TokenAuthentication</code> respectively. These can be added as middleware manually or through the helper methods.</p><pre><code class="ruby">conn.basic_auth('pita', 'ch1ps')
conn.token_auth('pitach1ps-token')
</code></pre><h3>Proxies</h3><p>To specify an HTTP proxy:</p><pre><code class="ruby">Faraday.new(:proxy =&gt; 'http://proxy.example.com:80')
Faraday.new(:proxy =&gt; {
  :uri      =&gt; 'http://proxy.example.com',
  :user     =&gt; 'foo',
  :password =&gt; 'bar'
})
</code></pre><h3>SSL</h3><p>See the <a href="https://github.com/technoweenie/faraday/wiki/Setting-up-SSL-certificates">Setting up SSL certificates</a> wiki page.</p><pre><code class="ruby">conn = Faraday.new('https://encrypted.google.com', :ssl =&gt; {
  :ca_path =&gt; "/usr/lib/ssl/certs"
})
conn.get '/search?q=asdf'
</code></pre><h2>Faraday Middleware</h2><p>Like a Rack app, a <code>Faraday::Connection</code> object has a list of middlewares. Faraday middlewares are passed an <code>env</code> hash that has request and response information. Middlewares can manipulate this information before and after a request is executed.</p><p>To make this more concrete, let's take a look at a new <code>Faraday::Connection</code>:</p><pre><code class="ruby">conn = Faraday.new
conn.builder

&gt; #&lt;Faraday::Builder:0x00000131239308
    @handlers=[Faraday::Request::UrlEncoded, Faraday::Adapter::NetHttp]&gt;
</code></pre><p><code>Faraday::Builder</code> is analogus to <code>Rack::Builder</code>. The newly initialized <code>Faraday::Connection</code> object has a middleware <code>Faraday::Request::UrlEncoded</code> in front of an adapter <code>Faraday::Adapter::NetHttp</code>. When a connection object executes a request, it creates a shared <code>env</code> hash, wraps the outer middlewares around each inner middleware, and executes the <code>call</code> method. Also like a Rack application, the adapter at the end of the builder chain is what actually executes the request.</p><p>Middlewares can be grouped into 3 types: request middlewares, response middlewares, and adapters. The distinction between the three is cosmetic. The following two initializers are equivalent:</p><pre><code class="ruby">Faraday.new do |builder|
  builder.request  :retry
  builder.request  :basic_authentication, 'login', 'pass'
  builder.response :logger
  builder.adapter  :net_http
end

Faraday.new do |builder|
  builder.use Faraday::Request::Retry
  builder.use Faraday::Request::BasicAuthentication, 'login', 'pass'
  builder.use Faraday::Response::Logger
  builder.use Faraday::Adapter::NetHttp
end
</code></pre><h3>Using a Different HTTP Adapter</h3><p>If you wanted to use a different HTTP adapter, you can plug one in. For example, to use a EventMachine friendly client, you can switch to the EMHttp adapter:</p><pre><code class="ruby">conn = Faraday.new do |builder|
  builder.use Faraday::Adapter::EMHttp

  # alternative syntax that looks up registered adapters from lib/faraday/adapter.rb
  builder.adapter :em_http
end
</code></pre><p>Currently, the supported adapters are Net::HTTP, EM::HTTP, Excon, and Patron.</p><h3>Advanced Middleware Usage</h3><p>The order in which middleware is stacked is important. Like with Rack, the first middleware on the list wraps all others, while the last middleware is the innermost one, so that's usually the adapter.</p><pre><code class="ruby">conn = Faraday.new(:url =&gt; 'http://sushi.com') do |builder|
  # POST/PUT params encoders:
  builder.request  :multipart
  builder.request  :url_encoded

  builder.adapter  :net_http
end
</code></pre><p>This request middleware setup affects POST/PUT requests in the following way:</p><ol>
<li>
<code>Request::Multipart</code> checks for files in the payload, otherwise leaves everything untouched;</li>
<li>
<code>Request::UrlEncoded</code> encodes as "application/x-www-form-urlencoded" if not already encoded or of another type</li>
</ol><p>Swapping middleware means giving the other priority. Specifying the "Content-Type" for the request is explicitly stating which middleware should process it.</p><p>Examples:</p><pre><code class="ruby">payload = { :name =&gt; 'Maguro' }

# uploading a file:
payload = { :profile_pic =&gt; Faraday::UploadIO.new('avatar.jpg', 'image/jpeg') }

# "Multipart" middleware detects files and encodes with "multipart/form-data":
conn.put '/profile', payload
</code></pre><h3>Modifying the Middleware Stack</h3><p>Each <code>Faraday::Connection</code> instance has a <code>Faraday::Builder</code> instance that can be used to manipulate the middlewares stack.</p><pre><code class="ruby">conn = Faraday.new
conn.builder.swap(1, Faraday::Adapter::EMHttp)  # replace adapter
conn.builder.insert(0, MyCustomMiddleware)      # add middleware to beginning
conn.builder.delete(MyCustomMiddleware)
</code></pre><p>For a full list of actions, take a look at the <code>Faraday::Builder</code> documentation.</p><h3>Writing Middleware</h3><p>Middleware are classes that respond to <code>call</code>. They wrap the request/response cycle. When it's time to execute a middleware, it's called with an <code>env</code> hash that has information about the request and response. The general interface for a middleware is:</p><pre><code class="ruby">class MyCustomMiddleware
  def call(env)
    # do something with the request

    @app.call(env).on_complete do |env|
      # do something with the response
      # env[:response] is now filled in
    end
  end
end
</code></pre><p>It's important to do all processing of the response only in the on_complete block. This enables middleware to work in parallel mode where requests are asynchronous.</p><p><code>env</code> is a hash with symbol keys that contains info about the request and response.</p><pre><code>:method - a symbolized request method (:get, :post, :put, :delete, :option, :patch)
:body   - the request body that will eventually be converted to a string.
:url    - URI instance for the current request.
:status           - HTTP response status code
:request_headers  - hash of HTTP Headers to be sent to the server
:response_headers - Hash of HTTP headers from the server
:parallel_manager - sent if the connection is in parallel mode
:request - Hash of options for configuring the request.
  :timeout      - open/read timeout Integer in seconds
  :open_timeout - read timeout Integer in seconds
  :proxy        - Hash of proxy options
    :uri        - Proxy Server URI
    :user       - Proxy server username
    :password   - Proxy server password
:response - Faraday::Response instance. Available only after `on_complete`
:ssl - Hash of options for configuring SSL requests.
  :ca_path - path to directory with certificates
  :ca_file - path to certificate file
</code></pre><h3>Testing Middleware</h3><p>Faraday::Adapter::Test is an HTTP adapter middleware that lets you to fake responses.</p><pre><code class="ruby"># It's possible to define stubbed request outside a test adapter block.
stubs = Faraday::Adapter::Test::Stubs.new do |stub|
  stub.get('/tamago') { [200, {}, 'egg'] }
end

# You can pass stubbed request to the test adapter or define them in a block
# or a combination of the two.
test = Faraday.new do |builder|
  builder.adapter :test, stubs do |stub|
    stub.get('/ebi') {[ 200, {}, 'shrimp' ]}
  end
end

# It's also possible to stub additional requests after the connection has
# been initialized. This is useful for testing.
stubs.get('/uni') {[ 200, {}, 'urchin' ]}

resp = test.get '/tamago'
resp.body # =&gt; 'egg'
resp = test.get '/ebi'
resp.body # =&gt; 'shrimp'
resp = test.get '/uni'
resp.body # =&gt; 'urchin'
resp = test.get '/else' #=&gt; raises "no such stub" error

# If you like, you can treat your stubs as mocks by verifying that all of
# the stubbed calls were made. NOTE that this feature is still fairly
# experimental: It will not verify the order or count of any stub, only that
# it was called once during the course of the test.
stubs.verify_stubbed_calls
</code></pre><h3>Useful Middleware</h3><ul>
<li>
<a href="https://github.com/pengwynn/faraday_middleware">faraday-middleware</a> - collection of Faraday middlewares.</li>
<li>
<a href="https://github.com/dmarkow/faraday_yaml">faraday_yaml</a> - yaml request/response processing</li>
</ul>
</div>
<script src="../../../../assets/post-6546d1eaa44666cb1ab3152c118eceec.js" type="text/javascript"></script>
<script>
  //<![CDATA[
    hljs.initHighlightingOnLoad();
  //]]>
</script>
<script type='text/javascript'>
  // HackerNews
  (function(d, t) {
    var g = d.createElement(t),
        s = d.getElementsByTagName(t)[0];
    g.src = '//hnbutton.appspot.com/static/hn.js';
    s.parentNode.insertBefore(g, s);
  }(document, 'script'));

  // Twitter
  !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");

  // Google Plus
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>
<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname  = 'whatcodecraves';
  var disqus_title      = 'Faraday: One HTTP Client to Rule Them All';
  var disqus_identifier = '/posts/2012/03/12/faraday-one-http-client-to-rule-them-all';


  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


</div>
<div id='footer'>
<p>
Copyright Jerry Cheung 2007 - 2014 &nbsp;&nbsp;
<a href="https://github.com/jch/whatcoderaves.com">Source for this blog</a>
</p>
</div>
</div>
</body>
</html>
